---
title: "singleCell_분석_기초"
author: "yeji Bae"
date: "2024-08-03"
output: html_document
---

2023.04.26 복사본. -> 2024.04.27 수정 -> 2024.08.03 cellranger 8.0.0 + seurat v5 

해당 스크립트는 "실전 단일세포 데이터 분석: 예제 코드와 데이터로 배우는 생물정보 분석 기술" 책에서 따라 할 수 있도록 제작된 실습 스크립트 '기초편' 입니다. 

현재 보고 계시는 코드는 카운트 매트릭스 생성 후, 싱글셀 데이터 분석을 위해 슈랏을 이용한 기본 코드이며,조금 더 심화된 코드를 확인 하고 싶다면 singleCell_분석_고급편.Rmd 파일을 확인해주세요.

각 코드블럭에 대한 자세한 설명은 책의 챕터 05부터 챕터 10까지를 참고바랍니다.

질문 사항이 있거나, 코드를 돌리는데 어려움이 있다면 github페이지에서 -> 'issue' 탭 -> 'New issue' 버튼을 클릭해서 작성해주시면 빠른 시일내에 답변드리겠습니다. 

Question: R script or Rmd script? 

```{r setup, include=FALSE} 
# 작업 디렉토리 설정
knitr::opts_knit$set(root.dir = getwd()) # 스크립크 위치를 작업 디렉토리로 설정
# knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # 프로젝트를 작업 디렉토리로 설정
```

# 데이터 설명 

TODO: 데이터 설명 
TODO: 데이터 구조 설명 
스크립스를 실행하기 전 모든 셀 레인저의 아웃풋 다음과 같은 구조로 저장되어 있어야합니다. 
만약 셀 레인저를 실행하기 어려운 환경이라면 _______ 에서 git clone 을 이용해 다운받아주세요. 

# 코드 실행 
코드를 하이라이트 한 뒤 위쪽 'Run' 버튼을 클릭하거나 command + return 단축키를 이용해서 실행시킬 수 있습니다. 코드 블록 ```{r}``` 에 포함되는 코드들은 해당 블록의 삼각형 버튼을 클릭하면 한번에 실행됩니다. 
TODO: window 단축키? 

# Chapter 05 슈랏 오브젝트, 품질관리 및 필터링"
## 5.1 슈랏 오브젝트 만들기 
[코드 5-1] 필요한 패키지 설치 및 불러오기
```{r}
# 필요한 패키지 설치  
# 1
install.packages("Seurat") 
remotes::install_github("satijalab/seurat", "seurat5", quiet = TRUE)
install.packages("dplyr") 
install.packages("hdf5r")
install.packages("BiocManager")
BiocManager::install("glmGamPoi")

# 패키지 불러오기  
library(Seurat) 
library(dplyr) 
library(hdf5r)
library(glmGamPoi)
```

[코드 5-2] 2가지 방법으로 슈랏 오브젝트 생성하기
```{r}
# [1] h5 파일 이용하기
count_SRR13911909.h5 <- Read10X_h5("../data/count_SRR13911909/outs/filtered_feature_bc_matrix.h5")
SRR13911909.h5.sobj_ori <- CreateSeuratObject(counts = count_SRR13911909.h5, project = "pbmc_alzheimer")

# [2] Market Exchange Format(MEX) 구조 폴더 이용하기 
count_SRR13911909 <- Read10X(data.dir =  "../data/count_SRR13911909/outs/filtered_feature_bc_matrix/")
SRR13911909.sobj_ori <- CreateSeuratObject(counts = count_SRR13911909, project = "pbmc_alzheimer")
```

(참고)[코드 5-3] 슈랏 오브젝트 생성 두 가지 방법의 시간 비교해보기  
해당 코드 블럭을 한번에 실행시켜줘야 정확한 시간을 얻을 수 있습니다. 한번에 하이라이트 해서 실행시키거나, 코드 블록의 오른쪽 위 화살표 버튼을 이용해서 실행해주세요. 
```{r}
# [1] h5 파일 이용하기
start <- Sys.time() # 시작 시간 
count_SRR13911909.h5 <- Read10X_h5("../data/count_SRR13911909/outs/filtered_feature_bc_matrix.h5")
SRR13911909.h5.sobj_ori <- CreateSeuratObject(counts = count_SRR13911909.h5, project = "pbmc_alzheimer")
print( Sys.time() - start ) # 현재 시간 – 시작 시간 = 총 걸린 시간 (4.866736 secs)

# [2] Market Exchange Format(MEX) 구조 폴더 이용하기  
start <- Sys.time()
count_SRR13911909 <- Read10X(data.dir = "../data/count_SRR13911909/outs/filtered_feature_bc_matrix/")
SRR13911909.sobj_ori <- CreateSeuratObject(counts = count_SRR13911909, project = "pbmc_alzheimer")
print( Sys.time() - start )
```

[코드 5-4] 모든 샘플을 슈랏 오브젝트로 변형하기 (최소 발현량, 발현 세포 임계값 적용)
```{r}
# 각 샘플의 카운트 메트릭스를 슈랏 오브젝트로 변환하기
count_SRR13911909.h5 <- Read10X_h5("../data/count_SRR13911909/outs/filtered_feature_bc_matrix.h5", use.names = TRUE, unique.features = TRUE)
SRR13911909.h5.sobj <- CreateSeuratObject(counts = count_SRR13911909.h5, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)

count_SRR13911910.h5 <- Read10X_h5("../data/count_SRR13911910/outs/filtered_feature_bc_matrix.h5", use.names = TRUE, unique.features = TRUE)
SRR13911910.h5.sobj <- CreateSeuratObject(counts = count_SRR13911910.h5, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)

count_SRR13911911.h5 <- Read10X_h5("../data/count_SRR13911911/outs/filtered_feature_bc_matrix.h5", use.names = TRUE, unique.features = TRUE)
SRR13911911.h5.sobj <- CreateSeuratObject(counts = count_SRR13911911.h5, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)

count_SRR13911912.h5 <- Read10X_h5("../data/count_SRR13911912/outs/filtered_feature_bc_matrix.h5", use.names = TRUE, unique.features = TRUE)
SRR13911912.h5.sobj <- CreateSeuratObject(counts = count_SRR13911912.h5, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)

count_SRR13911913.h5 <- Read10X_h5("../data/count_SRR13911913/outs/filtered_feature_bc_matrix.h5", use.names = TRUE, unique.features = TRUE)
SRR13911913.h5.sobj <- CreateSeuratObject(counts = count_SRR13911913.h5, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)

count_SRR13911914.h5 <- Read10X_h5("../data/count_SRR13911914/outs/filtered_feature_bc_matrix.h5", use.names = TRUE, unique.features = TRUE)
SRR13911914.h5.sobj <- CreateSeuratObject(counts = count_SRR13911914.h5, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)
```


(심화)[코드 5-5] 많은 수의 샘플 변환을 for 구문를 이용해 한번에 실행하기
```{r}
# install.packages("stringr")
library(stringr) # 문자열 데이터를 조작하고 분석하는 유용한 함수

# data 폴더에 있는 파일들의 경로 얻기  
all_samples <- dir("../data", pattern = "^count_.*", full.names = TRUE)
all_samples_h5 <- paste0(all_samples, "/outs/filtered_feature_bc_matrix.h5") 

# # h5파일 경로와, 샘플 이름을 갖는 데이터프레임 생성
sample_manifest <- as.data.frame(all_samples_h5) %>% 
    mutate(sample_name = str_extract(all_samples_h5, "SRR\\d+")) 
sample_manifest

# 빈 리스트 생성 
seurat_objects_list <- list() 

# for 함수를 이용해서 all_seurat_objects 리스트에 각 샘플을 슈랏 오브젝트 형태로 저장
for(sample in sample_manifest$sample_name){ 
  print(sample)
  count <- Read10X_h5(glue::glue("../data/count_{sample}/outs/filtered_feature_bc_matrix.h5"), use.names = TRUE, unique.features = TRUE)
  seurat_obj <- CreateSeuratObject(counts = count, project = "pbmc_alzheimer", min.cells = 3, min.features = 200)
  seurat_objects_list[[sample]] <- seurat_obj
}

seurat_objects_list
```


(참고)[코드 5-6] 슈랏 오브젝트 둘러보기 
```{r}
# 슈랏 오브젝트 출력하기
SRR13911909.h5.sobj

# 슈랏 오브젝트 메인 크기 확인하기
dim(SRR13911909.h5.sobj)              # 유전자(feature) x 세포  
colnames(SRR13911909.h5.sobj)[1:10]   #  세포 바코드 첫 10개
rownames(SRR13911909.h5.sobj)[1:10]   #  유전자 첫 10개


# 메타데이터 확인하기  
SRR13911909.h5.sobj[[]] 
SRR13911909.h5.sobj@meta.data 

# RNA 에세이 확인하기 
SRR13911909.h5.sobj@assays$RNA
SRR13911909.h5.sobj[["RNA"]]

# 레이어 (카운트) 데이터 확인하기 
# 카운트 값만 포함 
SRR13911909.h5.sobj@assays$RNA@layers$counts
SRR13911909.h5.sobj[["RNA"]]@layers$counts
# 열과 행 포함 
SRR13911909.h5.sobj@assays$RNA$counts 
SRR13911909.h5.sobj[["RNA"]]$counts

# other: 슈랏 오브젝트 뒤에 @ 혹은 $을 입력 한 후 'tab'을 눌러서 어떤 데이터를 불러 올 수 있는지 확인해 보세요.
```

## 5.2 품질관리(QC) 및 필터링
[코드 5-7] SRR13911909 슈랏 오브젝트에 미토콘드리아 유전자 발현 비율 추가하기
```{r}
SRR13911909.h5.sobj[["percent.mt"]] <- PercentageFeatureSet(SRR13911909.h5.sobj, pattern = "^MT-")
```

[코드 5-8] SRR13911909 슈랏 오브젝트의 품질관리 바이올린 플롯 그리기
```{r}
VlnPlot(SRR13911909.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)	
```

[코드 5-9] SRR13911909 슈랏 오브젝트의 품질관리 유전자 산포도 플롯 그리기
```{r, fig.width = 6, fig.height= 6}
# 세포당 RNA 카운트와 발현된 고유 유전자 수의 상관 관계
FeatureScatter(SRR13911909.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

# 세포당 RNA 카운트와 미토콘드리아 발현 비율 상관 관계
FeatureScatter(SRR13911909.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")
```

[코드 5-10] SRR13911909 슈랏 오브젝트 필터링하기
```{r}
SRR13911909.h5.sobj <- subset(SRR13911909.h5.sobj, subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10)
```

[코드 5-11] 필터링된 SRR13911909 슈랏 오브젝트의 품질 관리 플롯 그리기
```{r}
# 바이올린 플롯
VlnPlot(SRR13911909.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)	

# 유전자 산포도 플롯
FeatureScatter(SRR13911909.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
FeatureScatter(SRR13911909.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")
```

[코드 5-12] 각 샘플에 미토콘드리아 발현 비율 추가
```{r}
SRR13911910.h5.sobj[["percent.mt"]] <- PercentageFeatureSet(SRR13911910.h5.sobj, pattern = "^MT-")
SRR13911911.h5.sobj[["percent.mt"]] <- PercentageFeatureSet(SRR13911911.h5.sobj, pattern = "^MT-")
SRR13911912.h5.sobj[["percent.mt"]] <- PercentageFeatureSet(SRR13911912.h5.sobj, pattern = "^MT-")
SRR13911913.h5.sobj[["percent.mt"]] <- PercentageFeatureSet(SRR13911913.h5.sobj, pattern = "^MT-")
SRR13911914.h5.sobj[["percent.mt"]] <- PercentageFeatureSet(SRR13911914.h5.sobj, pattern = "^MT-")
```

[코드 5-13] QC 시각화 하기 – 바이올린 플롯 
```{r}
VlnPlot(SRR13911910.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(SRR13911911.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(SRR13911912.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(SRR13911913.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(SRR13911914.h5.sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

[코드 5-14] QC 시각화 하기 – 유전자 산포도 
```{r, fig.width = 6, fig.height= 6}
# 세포당 RNA 카운트와 발현된 고유 유전자 수의 상관 관계  
FeatureScatter(SRR13911910.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# 세포당 RNA 카운트와 미토콘드리아 발현 비율 상관 관계
FeatureScatter(SRR13911910.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")

FeatureScatter(SRR13911911.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
FeatureScatter(SRR13911911.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(SRR13911912.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
FeatureScatter(SRR13911912.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(SRR13911913.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
FeatureScatter(SRR13911913.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(SRR13911914.h5.sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
FeatureScatter(SRR13911914.h5.sobj, feature1 = "nCount_RNA", feature2 = "percent.mt")
```

[코드 5-15] 각 샘플들의 품질관리 플롯들을 이용해서 필터링하기 
```{r}
SRR13911910.h5.sobj <- subset(SRR13911910.h5.sobj, subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10)
SRR13911911.h5.sobj <- subset(SRR13911911.h5.sobj, subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10)
SRR13911912.h5.sobj <- subset(SRR13911912.h5.sobj, subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10)
SRR13911913.h5.sobj <- subset(SRR13911913.h5.sobj, subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10)
SRR13911914.h5.sobj <- subset(SRR13911914.h5.sobj, subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10)
```

(심화) [코드 5-16] lapply를 이용하여 한번에 미트콘드리아 유전자 발현 비율 계산 및 필터링하기
```{r}
seurat_objects_list <- lapply(seurat_objects_list, function(sobj) {  
    sobj <- sobj %>%  
        PercentageFeatureSet(pattern = "^MT-", col.name = "percent.mt") %>%  
        subset(subset = nFeature_RNA > 400 & nFeature_RNA < 3500 & percent.mt < 10) 
}) 
```


# Chapter 06 데이터 정규화 및 통합
## 6.1 로그정규화 이용 
[코드 6-1] 각 샘플별 로그 정규화 실행하기
_NormalizeData()_: https://satijalab.org/seurat/reference/normalizedata 
```{r}
SRR13911909.h5.sobj_norm <- NormalizeData(SRR13911909.h5.sobj, verbose = TRUE) 
SRR13911910.h5.sobj_norm <- NormalizeData(SRR13911910.h5.sobj, verbose = FALSE)
SRR13911911.h5.sobj_norm <- NormalizeData(SRR13911911.h5.sobj, verbose = FALSE)
SRR13911912.h5.sobj_norm <- NormalizeData(SRR13911912.h5.sobj, verbose = FALSE)
SRR13911913.h5.sobj_norm <- NormalizeData(SRR13911913.h5.sobj, verbose = FALSE)
SRR13911914.h5.sobj_norm <- NormalizeData(SRR13911914.h5.sobj, verbose = FALSE)
```
```{r fig.width = 8}
hist(colSums(SRR13911909.h5.sobj_norm@assays$RNA$counts[1:1000,]), breaks = 100)
hist(colSums(SRR13911909.h5.sobj_norm@assays$RNA$data[1:1000,]), breaks = 100)
```


[코드 6-2] 각 샘플별 고변이 유전자 추출하기
```{r}
SRR13911909.h5.sobj_norm <- FindVariableFeatures(SRR13911909.h5.sobj_norm, selection.method = "vst", nfeatures = 2000, verbose = TRUE)
SRR13911910.h5.sobj_norm <- FindVariableFeatures(SRR13911910.h5.sobj_norm, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
SRR13911911.h5.sobj_norm <- FindVariableFeatures(SRR13911911.h5.sobj_norm, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
SRR13911912.h5.sobj_norm <- FindVariableFeatures(SRR13911912.h5.sobj_norm, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
SRR13911913.h5.sobj_norm <- FindVariableFeatures(SRR13911913.h5.sobj_norm, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
SRR13911914.h5.sobj_norm <- FindVariableFeatures(SRR13911914.h5.sobj_norm, selection.method = "vst", nfeatures = 2000, verbose = FALSE)

# 유의미한 유전자 확인하기 예시
VariableFeatures(SRR13911909.h5.sobj_norm)[1:10]
```

[코드 6-3] 각 샘플별 선택된 고변이 유전자들에 대해 스케일링하기
```{r}
SRR13911909.h5.sobj_norm <- ScaleData(SRR13911909.h5.sobj_norm, verbose = TRUE) 
SRR13911910.h5.sobj_norm <- ScaleData(SRR13911910.h5.sobj_norm, verbose = FALSE)
SRR13911911.h5.sobj_norm <- ScaleData(SRR13911911.h5.sobj_norm, verbose = FALSE)
SRR13911912.h5.sobj_norm <- ScaleData(SRR13911912.h5.sobj_norm, verbose = FALSE)
SRR13911913.h5.sobj_norm <- ScaleData(SRR13911913.h5.sobj_norm, verbose = FALSE)
SRR13911914.h5.sobj_norm <- ScaleData(SRR13911914.h5.sobj_norm, verbose = FALSE)
```

[코드 6-4] 정규화된 슈랏 오브젝트들을 하나의 리스트로 묶기 
```{r}
lognorm_list <- c(SRR13911909.h5.sobj_norm, SRR13911910.h5.sobj_norm, SRR13911911.h5.sobj_norm, SRR13911912.h5.sobj_norm, SRR13911913.h5.sobj_norm, SRR13911914.h5.sobj_norm)
```

(심화)[코드 6-5] 코드 6-1 부터 6-4까지를 함축한 명령어
```{r}
# 모든 샘플 정규화하고 하나의 리스트로 묶기
lognorm_list <- lapply(seurat_objects_list, function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
  x <- ScaleData(x) 
})
```

```{r}
# TODO 
# raw 데이터 
# SRR13911909.h5.sobj_norm[["RNA"]]$counts # 혹은 pbmc_alzheimer_Log_1@assays$RNA$counts.1
# 
# # 정규화 된 데이터 
# SRR13911909.h5.sobj_norm[["RNA"]]$data
# 
# SRR13911909.h5.sobj_norm@assays$RNA@layers$data[1:5,]
# SRR13911909.h5.sobj_norm@assays$RNA$data
# SRR13911909.h5.sobj_norm[["RNA"]]$data[1:5,]
```

```{r}
# TODO 
# 2024 to demo merged without integration -> batch effect 
# pbmc_alzheimer_Log_2 <- merge(SRR13911909.h5.sobj, y = c(SRR13911910.h5.sobj, SRR13911911.h5.sobj,SRR13911912.h5.sobj,SRR13911913.h5.sobj,SRR13911914.h5.sobj), add.cell.ids = c("SRR13911909", "SRR13911910", "SRR13911911", "SRR13911912", "SRR13911913", "SRR13911914"), project = "pbmc_alzheimer")
# 
# 
# dim(pbmc_alzheimer_Log_2[["RNA"]]$counts.1) #  21423 11325
# dim(pbmc_alzheimer_Log_2_joined[["RNA"]]$counts) # 24164 74134 
# pbmc_alzheimer_Log_2
#  
# pbmc_alzheimer_Log_2_joined <- pbmc_alzheimer_Log_2
# pbmc_alzheimer_Log_2_joined[["RNA"]] <- JoinLayers(pbmc_alzheimer_Log_2_joined[["RNA"]]) # all the counts into one count 
# 
# pbmc_alzheimer_Log_2_joined <- SCTransform(pbmc_alzheimer_Log_2_joined, verbose = FALSE)  # need? -> sure for the same condition
# 
# pbmc_alzheimer_Log_2_joined@meta.data <- pbmc_alzheimer_Log_2_joined@meta.data %>%
#   mutate(Run = ifelse(grepl("SRR13911909_", rownames(.)), "SRR13911909", 
#                               ifelse(grepl("SRR13911910_", rownames(.)), "SRR13911910",
#                                      ifelse(grepl("SRR13911911_", rownames(.)), "SRR13911911",
#                                             ifelse(grepl("SRR13911912_", rownames(.)), "SRR13911912",
#                                                    ifelse(grepl("SRR13911913_", rownames(.)), "SRR13911913",
#                                                           ifelse(grepl("SRR13911914_", rownames(.)), "SRR13911914", "NA")))))))
# 
# # manifest
# manifest <- read.csv("SraRunTable.txt")
# manifest <- manifest %>% # 필요한 컬럼만 추출해내기 
#   select(c(Run, Age, subject_status))
# 
# pbmc_alzheimer_Log_2_joined@meta.data[c("Run", "Age", "subject_status")] <-
#   manifest[match(pbmc_alzheimer_Log_2_joined$Run, manifest$Run), ]
# # saveRDS(pbmc_alzheimer_Log_2_joined, "./rds/pbmc_alzheimer_Log_2_joined.rds")
# 
# 
# pbmc_alzheimer_Log_2_joined <- RunPCA(pbmc_alzheimer_Log_2_joined, verbose = FALSE)
# pbmc_alzheimer_Log_2_joined <- RunUMAP(pbmc_alzheimer_Log_2_joined, reduction = "pca", dims = 1:30, verbose = FALSE)
# pbmc_alzheimer_Log_2_joined <- FindNeighbors(pbmc_alzheimer_Log_2_joined, reduction = "pca", dims = 1:30)
# pbmc_alzheimer_Log_2_joined <- FindClusters(pbmc_alzheimer_Log_2_joined, resolution = 0.3)
# 
# # UMAP group by age 
# DimPlot(
#   pbmc_alzheimer_Log_2_joined,
#   reduction = "umap",
#   group.by = "Age",
#   combine = FALSE, label.size = 2
# )
```

## 6.2 SCTranfrom 정규화 이용
[코드 6-6] SCTransform 정규화 실행하기
_SCTransform()_: https://satijalab.org/seurat/reference/sctransform 
```{r}
options(future.globals.maxSize = 100 * 1024^3)  # 1000=1GB
SRR13911909.h5.sobj_SCT <- SCTransform(SRR13911909.h5.sobj, vars.to.regress = "percent.mt", verbose = TRUE) 
SRR13911910.h5.sobj_SCT <- SCTransform(SRR13911910.h5.sobj, vars.to.regress = "percent.mt", verbose = FALSE) 
SRR13911911.h5.sobj_SCT <- SCTransform(SRR13911911.h5.sobj, vars.to.regress = "percent.mt", verbose = FALSE) 
SRR13911912.h5.sobj_SCT <- SCTransform(SRR13911912.h5.sobj, vars.to.regress = "percent.mt", verbose = FALSE) 
SRR13911913.h5.sobj_SCT <- SCTransform(SRR13911913.h5.sobj, vars.to.regress = "percent.mt", verbose = FALSE) 
SRR13911914.h5.sobj_SCT <- SCTransform(SRR13911914.h5.sobj, vars.to.regress = "percent.mt", verbose = FALSE) 
```

[코드 6-7] 활성화된 에세이 변경하기
```{r}
# "RNA"를 활성화된 에세이로 지정하기 
DefaultAssay(SRR13911909.h5.sobj_SCT) <- "RNA"

# "SCT"를 활성화된 에세이로 지정하기 
DefaultAssay(SRR13911909.h5.sobj_SCT) <- "SCT"
```


## 6.3 데이터 통합 

[코드 6-8] 여러 개의 슈랏 오브젝트를 하나의 리스트로 묶기 
```{r}
pbmc_alzheimer_SCT.list <- list(SRR13911909.h5.sobj_SCT, SRR13911910.h5.sobj_SCT, SRR13911911.h5.sobj_SCT, SRR13911912.h5.sobj_SCT, SRR13911913.h5.sobj_SCT, SRR13911914.h5.sobj_SCT)
```

(참고)[코드 6-9] 오브젝트 저장 및 불러오기
```{r}
# 오브젝트 저장 
saveRDS(pbmc_alzheimer_SCT.list, "./rds/pbmc_alzheimer_SCT.list.rds")

# 오브젝트 불러오기 
pbmc_alzheimer_SCT.list <- readRDS("./rds/pbmc_alzheimer_SCT.list.rds")
```

(참고)[코드 6-10] 오브젝트 삭제 및 메모리 정리 예시 
```{r}
# 불필요한 오브젝트 삭제  
rm(SRR13911909.h5.sobj_SCT) 
 
# 메모리 정리 
gc() 
```


(참고) [코드 6-11] 필요 없는 오브젝트들 일부 정리 
```{r}
rm(count_SRR13911909.h5, count_SRR13911910.h5, count_SRR13911911.h5, count_SRR13911912.h5, count_SRR13911913.h5, count_SRR13911914.h5)
rm(SRR13911909.h5.sobj_ori, SRR13911909.h5.sobj, SRR13911910.h5.sobj, SRR13911911.h5.sobj, SRR13911912.h5.sobj, SRR13911913.h5.sobj, SRR13911914.h5.sobj)
rm(SRR13911909.h5.sobj_norm, SRR13911910.h5.sobj_norm, SRR13911911.h5.sobj_norm, SRR13911912.h5.sobj_norm, SRR13911913.h5.sobj_norm, SRR13911914.h5.sobj_norm)

gc()
```
```{r}
# sct09_sd<- pbmc_alzheimer_SCT.list[[1]]@assays$SCT$scale.data
```


[코드 6-12] SCT 정규화된 샘플들을 앵커를 이용하여 CCA방법으로 통합하기
```{r}
# 샘플 간의 공통 유전자 찾기
features <- SelectIntegrationFeatures(object.list = pbmc_alzheimer_SCT.list, nfeatures = 3000) 
pbmc_alzheimer_SCT.list <- PrepSCTIntegration(object.list = pbmc_alzheimer_SCT.list, anchor.features = features) 

# 샘플 간의 앵커 찾기
pbmc_alzheimer_SCT.anchors <- FindIntegrationAnchors(object.list = pbmc_alzheimer_SCT.list, 
                                                     normalization.method = "SCT", 
                                                     anchor.features = features,
                                                     reduction = "cca")
saveRDS(pbmc_alzheimer_SCT.anchors, "./rds/pbmc_alzheimer_SCT.anchors.rds")

# 통합하기 
pbmc_alzheimer_SCT.combined <- IntegrateData(anchorset = pbmc_alzheimer_SCT.anchors, 
                                             normalization.method = "SCT") 
saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA.rds")
pbmc_alzheimer_SCT.combined <- readRDS("./rds/pbmc_alzheimer_SCT_CCA.rds")
```

```{r}
# sct09_sd_afterprep <- pbmc_alzheimer_SCT.list[[1]]@assays$SCT$scale.data
# identical(rownames(sct09_sd), rownames(sct09_sd_afterprep)) # FALSE 
```

(참고) [코드 6-13] R 환경 메모리 할당량 늘리기 
```{r}
# usethis 패키기 설치 및 불러오기
Install.packages("usethis")
library(usethis)

# R 메모리 할당량 늘리기
usethis::edit_r_environ() # 해당 코드를 실행하면 R 환경 설정 파일 ('.Renviron') 이 열립니다. 해당 파일에 'R_MAX_VSIZE=100Gb' 작성 후 저장한 후, R을 다시 시작하면 변경 사항이 적용됩니다. 
```

(참고)[코드 6-14] future 패키지를 이용한 병렬 처리 설정
```{r}
# future 패키지 설치 및 불러오기  
install.packages("future") 
library(future) 

# 병렬 처리 전략 설정  
plan("multicore", workders = 8)
plan("sequential")    # 복원  # TODO 정리 

# 병렬 작업 중 전역 환경에서 사용할 수 있는 메모리의 최대 크기 제한.  
options(future.globals.maxSize = 800000 * 1024^2)  # 8000=8GB
```

(예시) 앵커 들여다보기
```{r}
# 앵커 확인 
pbmc_alzheimer_SCT.anchors

# 통합된 데이터 들여다보기  
identical(pbmc_alzheimer_SCT.combined[["integrated"]]$data, pbmc_alzheimer_SCT.combined[["integrated"]]$scale.data) # FALSE
dim(pbmc_alzheimer_SCT.combined[["integrated"]]$data) # 3000 74134
dim(pbmc_alzheimer_SCT.combined[["integrated"]]$scale.data) # 3000 74134

pbmc_alzheimer_SCT.combined[["integrated"]]$data[1:5, 1:5]
pbmc_alzheimer_SCT.combined[["integrated"]]$scale.data[1:5, 1:5]
```

```{r}
## ??
merged_sobj <- merge(SRR13911909.h5.sobj_norm, 
                     y = c(SRR13911910.h5.sobj_norm, SRR13911911.h5.sobj_norm, 
                           SRR13911912.h5.sobj_norm, SRR13911913.h5.sobj_norm, 
                           SRR13911914.h5.sobj_norm))

merged_sobj <- JoinLayers(merged_sobj) 
merged_sobj <- RunPCA(merged_sobj) 

merged_sobj_integrated <- IntegrateLayers(
  object = merged_sobj, 
  method = CCAIntegration,
  orig.reduction = "pca", 
  new.reduction = "integrated.cca",
  verbose = FALSE
)
# Error in UseMethod(generic = "Assays", object = object) : 
#   no applicable method for 'Assays' applied to an object of class "NULL"

merged_sobj_integrated <- IntegrateLayers(
  object = merged_sobj, method = HarmonyIntegration,
  orig.reduction = "pca", new.reduction = "harmony",
  verbose = FALSE
)
# Error in names(groups) <- "group" : attempt to set an attribute on NULL
```

```{r}
## ??
merged_sobj <- merge(SRR13911909.h5.sobj_norm, y = c(SRR13911910.h5.sobj_norm, SRR13911911.h5.sobj_norm, SRR13911912.h5.sobj_norm, SRR13911913.h5.sobj_norm, SRR13911914.h5.sobj_norm))

job::job({merged_sobj <- RunPCA(merged_sobj, verbose = FALSE) %>%
  RunUMAP(., reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(., reduction = "pca", dims = 1:30) %>% 
  FindClusters(., resolution = c(0.1, 0.3, 0.5))})
```


# Chapter 07 차원 축소 및 클러스터링
SCTransform 정규화 및 CCA 통합 된 pbmc_alzheimer_SCT.combined로 이어서 진행합니다. 
  - _RunPCA()_: PCA on the scaled data
  - _RunUMAP()_
  - _FindNeighbors()_
  - _FindClusters()_ 

## 7.1 선형 차원 축소 - 주성분 분석
[코드 7-1] PCA 계산 및 시각화
```{r}
# pca 실행
pbmc_alzheimer_SCT.combined <- RunPCA(pbmc_alzheimer_SCT.combined, verbose = TRUE)

# pca 시각화
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "pca", dims = c(2,4))
```

[코드 7-2] PCA 엘보우 플롯 시각화 (주성분 50개) 
```{r}
ElbowPlot(pbmc_alzheimer_SCT.combined, ndims = 50, reduction = 'pca')
```

[코드 7-3] 주성분별(PC1-PC9) 히트맵 시각화
```{r, fig.height = 10, fig.width=10}
DimHeatmap(pbmc_alzheimer_SCT.combined, dims = 1:9, cells = 500, balanced = TRUE) 
```

```{R}
# testing? 
# Idents(pbmc_alzheimer_SCT.combined) <-  "orig.ident"
# pdf("./results/pca_results.pdf", width = 10)
print(pbmc_alzheimer_SCT.combined[["pca"]], dims = 1:10, nfeatures = 5)
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "pca") + NoLegend() # 나중에 clustering 한 후에, 해당 색칠해서 확인해보면 어느 pc dimension이 어떤 cell type을 구분할 수 있는지도 보인다. 
ElbowPlot(pbmc_alzheimer_SCT.combined, ndims = 30, reduction = 'pca') # -> 20 dimension 사용 예정
DimHeatmap(pbmc_alzheimer_SCT.combined, dims = 25:30, cells = 500, balanced = TRUE)
# dev.off()
```

## 7.2 비선형 차원 축소 - t-SNE/UMAP

[코드 7-4] t-SNE 계산 및 시각화
```{r}
# tsne 실행
pbmc_alzheimer_SCT.combined <- RunTSNE(pbmc_alzheimer_SCT.combined, reduction = "pca", dims = 1:30, verbose = F)

# tsne 플롯 시각화 
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "tsne")
```

[코드 7-5] UMAP 계산 및 시각화 
```{r}
# umap 실행
pbmc_alzheimer_SCT.combined <- RunUMAP(pbmc_alzheimer_SCT.combined, reduction = "pca", dims = 1:30, verbose = FALSE)

# umap 플롯 시각화 
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "umap")
```


## 7.3 클러스터링 
[코드 7-5] 클러스터링
```{r}
pbmc_alzheimer_SCT.combined <- FindNeighbors(pbmc_alzheimer_SCT.combined, reduction = "pca", dims = 1:30)
pbmc_alzheimer_SCT.combined <- FindClusters(pbmc_alzheimer_SCT.combined, resolution = c(0.1,0.3, 0.5))
```

```{r}
saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA_UMAP.rds")
```


(심화)[코드 7-6] 차원축소 및 클러스터링 한번에 진행하기 
[코드 7-1]부터 [코드 7-5]까지 한번에 실행하는 코드입니다. 
```{r}
pbmc_alzheimer_SCT.combined <- RunPCA(pbmc_alzheimer_SCT.combined, verbose = FALSE) %>%
  RunUMAP(., reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(., reduction = "pca", dims = 1:30) %>% 
  FindClusters(., resolution = c(0.1, 0.3, 0.5))
```

```{r}
# Computing nearest neighbor graph
# Computing SNN
# Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck
# 
# Number of nodes: 74584
# Number of edges: 2794483
# 
# Running Louvain algorithm...
# 0%   10   20   30   40   50   60   70   80   90   100%
# [----|----|----|----|----|----|----|----|----|----|
# **************************************************|
# Maximum modularity in 10 random starts: 0.9711
# Number of communities: 11
# Elapsed time: 42 seconds
# Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck
# 
# Number of nodes: 74584
# Number of edges: 2794483
# 
# Running Louvain algorithm...
# 0%   10   20   30   40   50   60   70   80   90   100%
# [----|----|----|----|----|----|----|----|----|----|
# **************************************************|
# Maximum modularity in 10 random starts: 0.9416
# Number of communities: 16
# Elapsed time: 34 seconds
# Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck
# 
# Number of nodes: 74584
# Number of edges: 2794483
# 
# Running Louvain algorithm...
# 0%   10   20   30   40   50   60   70   80   90   100%
# [----|----|----|----|----|----|----|----|----|----|
# **************************************************|
# Maximum modularity in 10 random starts: 0.9224
# Number of communities: 22
# Elapsed time: 33 seconds
```


[코드 7-7] UMAP 시각화 
```{r}
# pdf("./results/UMAP_integrated_snn_res.0.1_0.3_0.5.pdf", width = 10)
Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.1"
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "umap")

Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.3"
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "umap")

Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.5"
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "umap")
# dev.off()
```

[코드 7-8] TSNE 시각화 
```{r}
# pdf("./results/TSNE_integrated_snn_res.0.1_0.3_0.5.pdf", width = 10)
Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.1"
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "tsne")

Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.3"
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "tsne")

Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.5"
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "tsne")
# dev.off()
```


# Chapter 08 배치 효과 교정 
```{r}
# test 1
lognorm_list_processed <- lapply(lognorm_list, function(sobj) {  
    sobj <- sobj %>%  
      SCTransform(.,verbose = FALSE) %>%
      RunPCA(., verbose = FALSE) %>%
      RunUMAP(., reduction = "pca", dims = 1:20, verbose = FALSE) %>%
      FindNeighbors(., reduction = "pca", dims = 1:20) %>% 
      FindClusters(., resolution = c(0.3)) # option
}) 
# merge them
lognorm_list_processed_merged <- scCustomixe::Merge_Seurat_List(
  lognorm_list_processed,
  add.cell.ids = NULL,
  merge.data = TRUE
)
# draw dimplot 


# test 2 
# merge them 
# then run dimension reduction 
```

[코드 8-1] 배치 효과 교정 없이 슈랏 오브젝트들 합치기
```{r}
SCT_merged <- merge(SRR13911909.h5.sobj_SCT,  y = c(SRR13911910.h5.sobj_SCT,SRR13911911.h5.sobj_SCT, SRR13911912.h5.sobj_SCT,SRR13911913.h5.sobj_SCT,SRR13911914.h5.sobj_SCT), project = "pbmc_alzheimer")
```

(참고)[코드 8-2] 배치 효과 교정 없이 슈랏 오브젝트들 합치기 - 샘플 이름 이용 
```{r}
SCT_merged_named <- merge(SRR13911909.h5.sobj_SCT, y = c(SRR13911910.h5.sobj_SCT), add.cell.ids = c("SRR13911909", "SRR13911910"), project = "pbmc_alzheimer")
```

[코드 8-3] 배치 효과 교정 없이 합쳐진 슈랏 오브젝트 차원 축소 및 클러스터링
```{r}
# [코드 6-12] 에서 구한 공통 유전자 3000개 이용 
VariableFeatures(SCT_merged) <- features

# 차원 축소 및 클러스터링 
SCT_merged <- RunPCA(SCT_merged, verbose = FALSE) %>%
  RunUMAP(., reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  RunTSNE(., reduction = "pca", dims = 1:30, verbose = FALSE)

job::job({saveRDS(SCT_merged, "./rds/SCT_merged.rds")})
```


[코드 8-4] 메타 데이터 추가하기 - 배치 효과 교정 없이 합쳐진 슈랏 오브젝트
```{r}
# 메타 데이터에 샘플 이름 추가하기, 'Run' 컬럼 
SCT_merged@meta.data <- SCT_merged@meta.data %>%
  mutate(Run = ifelse(grepl("_1", rownames(.)), "SRR13911909", 
                              ifelse(grepl("_2", rownames(.)), "SRR13911910",
                                     ifelse(grepl("_3", rownames(.)), "SRR13911911",
                                            ifelse(grepl("_4", rownames(.)), "SRR13911912",
                                                   ifelse(grepl("_5", rownames(.)), "SRR13911913",
                                                          ifelse(grepl("_6", rownames(.)), "SRR13911914", "NA")))))))

# 샘플 메타데이터 읽기 
metadata <- read.csv("../data/SraRunTable.csv")
metadata_subset <- metadata %>%
  select(c(Run, AGE, subject_status)) # 필요한 컬럼만 추출해내기

# 샘플 메타데이터 추가하기
SCT_merged@meta.data[c("Run", "AGE", "subject_status")] <-
  metadata_subset[match(SCT_merged$Run, metadata_subset$Run), ]
```

[코드 8-5] 메타 데이터 추가하기 - 배치 효과 교정된 슈랏 오브젝트
```{r}
# 메타 데이터에 샘플 이름 추가하기, 'Run' 컬럼 
pbmc_alzheimer_SCT.combined@meta.data <- pbmc_alzheimer_SCT.combined@meta.data %>%
  mutate(Run = ifelse(grepl("_1", rownames(.)), "SRR13911909", 
                              ifelse(grepl("_2", rownames(.)), "SRR13911910",
                                     ifelse(grepl("_3", rownames(.)), "SRR13911911",
                                            ifelse(grepl("_4", rownames(.)), "SRR13911912",
                                                   ifelse(grepl("_5", rownames(.)), "SRR13911913",
                                                          ifelse(grepl("_6", rownames(.)), "SRR13911914", "NA")))))))


# 샘플 메타데이터 추가하기
pbmc_alzheimer_SCT.combined@meta.data[c("Run", "AGE", "subject_status")] <-
  metadata_subset[match(pbmc_alzheimer_SCT.combined$Run, metadata_subset$Run), ]
```

```{r}
add_sample_name <- function(sobj, names){
}
```


[코드 8-6] 배치 효과 확인을 위한 UMAP & TSNE 시각화 
```{r fig.width = 13}
# 배치 교정 없이 합쳐진 슈랏 오브젝트 
Idents(SCT_merged) <-  SCT_merged@meta.data[["Run"]]
DimPlot(SCT_merged, pt.size = 0.01, reduction = "umap")
DimPlot(SCT_merged, pt.size = 0.01, reduction = "tsne")

# 배치 교정 통합된 슈랏 오브젝트
Idents(pbmc_alzheimer_SCT.combined) <-  pbmc_alzheimer_SCT.combined@meta.data[["Run"]] 
DimPlot(pbmc_alzheimer_SCT.combined, pt.size = 0.01, reduction = "umap") 
DimPlot(pbmc_alzheimer_SCT.combined, pt.size = 0.01, reduction = "tsne") 
```

[코드 8-7] 샘플별로 나눠서 UMAP 그리기
```{r}
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "umap", split.by = "Run")
```

```{r}
#2024.02.01 try other integration on SCT
dim(pbmc_alzheimer_SCT.combined@reductions$integrated.cca@cell.embeddings)
# RNA - counts, data, scaled.data
# SCT - counts, data, scaled.data
# Integrated - data, scaled.data

dim(pbmc_alzheimer_SCT.combined@assays$RNA$counts) # 24164, 74134
dim(pbmc_alzheimer_SCT.combined@assays$SCT@counts) # 21737 74134
dim(pbmc_alzheimer_SCT.combined@assays$integrated$data) # 2000, 74134
dim(pbmc_alzheimer_SCT.combined@assays$integrated$scale.data) # 2000, 74134
identical(pbmc_alzheimer_SCT.combined@assays$integrated$data, pbmc_alzheimer_SCT.combined@assays$integrated$scale.data) # FALSE

pbmc_alzheimer_SCT.combined@assays$SCT@counts[1:5,1:5]
pbmc_alzheimer_SCT.combined@assays$integrated$data[1:5,1:5]
pbmc_alzheimer_SCT.combined@assays$integrated$scale.data[1:5,1:5]
dim(pbmc_alzheimer_SCT.combined@assays$SCT@scale.data) # 2000, 74134
```

[코드 8-8] 하모니 방법을 이용한 배치 효과 교정 및 데이터 통합  
```{r}
# 하모니 설치
install.packages("harmony")

# 하모니 통합 
SCT_merged <- IntegrateLayers(  
  object = SCT_merged,
  method = HarmonyIntegration,          # 방법 변경 가능 
  normalization.method = "SCT", 
  new.reduction = "integrated.harmony", # 새로운 차원축소 데이터 이름 
  verbose = F
)
```

[코드 8-9] 배치효과 확인 - 하모니로 교정 된 슈랏 오브젝트  
```{r fig.width = 15}
# 클러스터링 및 UMAP 차원 축소 
SCT_merged <- FindNeighbors(SCT_merged, reduction = "integrated.harmony", dims = 1:30, verbose = F) %>%
  FindClusters(., resolution = 0.3, cluster.name = "harmony_clusters", verbose =F) %>%
  RunUMAP(., reduction = "integrated.harmony", dims = 1:30, reduction.name = "umap.sct.harmony", verbose = F)

# 하모니 UMAP 시각화  
DimPlot(SCT_merged, pt.size = 0.01, group.by = "Run", reduction = "umap.sct.harmony")
```

```{r}
# identical(SCT_merged@assays$SCT@counts, sobj_SCT@assays$SCT@counts) # TRUE
# identical(SCT_merged@assays$SCT@data, sobj_SCT@assays$SCT@data) # TRUE
```

```{r}
# # RPMC 통합 
# SCT_merged <- IntegrateLayers( 
#   object = SCT_merged, method = RPCAIntegration, 
#   orig.reduction = "pca", new.reduction = "integrated.rpca", 
#   verbose = F 
# ) 
# 
# # FastMNN 통합 
# SCT_merged <- IntegrateLayers( 
#   object = SCT_merged, method = FastMNNIntegration, 
#   new.reduction = "integrated.mnn", 
#   verbose = F 
# ) 
```


[코드 8-11] 로그 정규화환 샘플들에대한 통합된 표현 공간 생성 및 시각화
```{r}
# 로그 정규화 된 샘플들을 하나의 오브젝트로 합치기  
Lognorm_merged <- merge(SRR13911909.h5.sobj_norm, y= c(SRR13911910.h5.sobj_norm, SRR13911911.h5.sobj_norm, SRR13911912.h5.sobj_norm, SRR13911913.h5.sobj_norm, SRR13911914.h5.sobj_norm))

# 데이터 전처리 
Lognorm_merged <- FindVariableFeatures(Lognorm_merged)
Lognorm_merged <- ScaleData(Lognorm_merged)
Lognorm_merged <- RunPCA(Lognorm_merged)

# IntegrateLayers 실행
Lognorm_merged <- IntegrateLayers(object = Lognorm_merged, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca", verbose = F)

# 새롭게 생성된 차원 축소 데이터를 기반으로 UMAP 실행
Lognorm_merged <- RunUMAP(Lognorm_merged, reduction = "integrated.cca", dims = 1:30, reduction.name = "umap.lognorm.cca", verbose = F)

# 샘플 열 추가 및 시각화 
Lognorm_merged@meta.data <- Lognorm_merged@meta.data %>%
  mutate(Run = ifelse(grepl("_1", rownames(.)), "SRR13911909", 
                              ifelse(grepl("_2", rownames(.)), "SRR13911910",
                                     ifelse(grepl("_3", rownames(.)), "SRR13911911",
                                            ifelse(grepl("_4", rownames(.)), "SRR13911912",
                                                   ifelse(grepl("_5", rownames(.)), "SRR13911913",
                                                          ifelse(grepl("_6", rownames(.)), "SRR13911914", "NA")))))))
Idents(Lognorm_merged) <- "Run"
DimPlot(Lognorm_merged, pt.size = 0.01, alpha = 0.2, reduction = "umap.lognorm.cca")
```
Once integrative analysis is complete, you can rejoin the layers - which collapses the individual datasets together and recreates the original counts and data layers. You will need to do this before performing any differential expression analysis. However, you can always resplit the layers in case you would like to reperform integrative analysis.
https://satijalab.org/seurat/articles/seurat5_integration 

UMAP 상에서 integration 이 된것 같으면 JoinLayers() 함수를 실행해서 실제 카운트를 합쳐 새로운 counts 와 data 레이어를 만들어 낼 수 있습니다. 

```{r}
DefaultAssay(obj) <- "RNA" # integrated didn't work for IntegrateLayers, SCT also doesn't work 
obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
obj[["RNA"]]

pbmc_alzheimer_SCT.combined
obj
pbmc_alzheimer_SCT.combined[["RNA"]]
obj[["RNA"]]

identical(pbmc_alzheimer_SCT.combined[["RNA"]]$scale.data, obj[["RNA"]]$scale.data) # TRUE
obj[["RNA"]]$data # 24164 x 74134
obj[["RNA"]]$count # 24164 x 74134
```


# Chapter 09 세포 유형 주석
## 9.1 세포 특정 마커 이용

```{r}
# sanity check
pbmc_alzheimer_SCT_CCA_UMAP <- readRDS("./rds/pbmc_alzheimer_SCT_CCA_UMAP.rds")

SCT_merged <- readRDS("./rds/SCT_merged.rds")
dim(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@counts) # 22807 73252
identical(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@counts,
          SCT_merged@assays$SCT@counts) # TRUE
identical(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@data,
          SCT_merged@assays$SCT@data) # TRUE
identical(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@scale.data,
          SCT_merged@assays$SCT@scale.data) # FALSE TODO: why false? does integration replace only scale.data? -> 그런것 같다 

# 일단 PrepSCTFindmarkers을 실행하기 전 counts와 data는 다르다. scale.data는 동일하다 
DefaultAssay(pbmc_alzheimer_SCT_CCA_UMAP) <- "SCT"
pbmc_alzheimer_SCT.combined <- PrepSCTFindMarkers(object = pbmc_alzheimer_SCT_CCA_UMAP) # recorreecting SCT counts using minimum median counts 1
identical(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@counts,
          pbmc_alzheimer_SCT.combined@assays$SCT@counts) # FALSE 
identical(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@data,
          pbmc_alzheimer_SCT.combined@assays$SCT@data)   # FALSE 
identical(pbmc_alzheimer_SCT_CCA_UMAP@assays$SCT@scale.data,
          pbmc_alzheimer_SCT.combined@assays$SCT@scale.data) # TRUE 
```

```{r}
pbmc_alzheimer_SCT.combined <- readRDS("./rds/pbmc_alzheimer_SCT_CCA_UMAP.rds")
```


[코드 9-1] 각 클러스터의 마커 찾기
```{r}
# 카운트값 재보정
pbmc_alzheimer_SCT.combined <- PrepSCTFindMarkers(object = pbmc_alzheimer_SCT.combined)
saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA_UMAP_prepSCT.rds")

# 설정 
DefaultAssay(pbmc_alzheimer_SCT.combined) <- "SCT"
Idents(pbmc_alzheimer_SCT.combined) <- "integrated_snn_res.0.3"

# 각 클러스터의 유전자 마커 찾기 (다소 오래 걸릴 수 있습니다.)
job::job({
  markers <- FindAllMarkers(pbmc_alzheimer_SCT.combined , only.pos = TRUE)
})

# 마커 정보 rds 파일로 저장하기 
saveRDS(markers, "./rds/pbmc_alzheimer_SCT_CCA_UMAP_markers_res_0.3.rds")
```

[코드 9-2] 클러스터별 유의미한 상위 20개 마커 추출
```{r}
# 각 클러스터별 유의미한 마커 추출하기  
markers_select <- markers %>%
    group_by(cluster) %>%       # 클러스터별로 그룹화
    filter(avg_log2FC > 1 &     # 발현 차이가 큰 유전자만 선택
           p_val_adj < 0.05)    # 통계적으로 유의한 유전자만 선택

# 각 클러스터별 상위 20개 마커 추출하기  
markers_select %>%
  arrange(desc(avg_log2FC)) %>%     # log2FC 기준으로 내림차순 정렬
  slice_head(n = 20) %>%            # 상위 20개 유전자 선택
  ungroup() -> top20                # 그룹화 해제 및 결과를 하나의 데이터프레임으로 저장

# 클러스터 0의 상위 20개 마커 유전자 
top20[top20$cluster == 0, ]$gene
```

[코드 9-3] 알려진 마커들을 이용해서 세포 유형 주석 달기 
```{r}
# 논문에서 주어진 세포 유형 별 마커들 
paper_markers <- list(
  B_cell = c("CD19", "MS4A1"),
  HSC = c("NCOR2", "NKX3-1", "HLX", "PRNP"),
  Monocyte = c("CLEC12A", "MS4A6A", "ZFP36L2"),
  NK_cell = c("GNLY", "GZMB", "SAMD3", "DOCK2"),
  CD4_T_cell = c("CD4", "CD3D", "CD3E", "CD3G"),
  CD8_T_cell = c("CD8A", "CD8B", "CD3D", "CD3E", "CD3G")
)

# 각 클러스터의 세포 유형 점수 구하기 
results <- list()

# 각 클러스터마다 반복 
for (cluster_n in unique(markers$cluster)){
  cluster_markers <- markers %>%
    filter(cluster == cluster_n)
  
  # 각 세포유형 마커들 중 매칭된 갯수 비율 계산  
  total_genes <- length(cluster_markers$gene)
  match_counts <- sapply(paper_markers, function(x) sum(x %in% cluster_markers$gene)/length(x))
  
  # 리스트로 정리 
  cluster_name <- paste("Cluster", cluster_n)
  results[[cluster_name]] <- match_counts
}

# 리스트들을 하나의 매트릭스로 만들기 
results_matrix <- t(sapply(results, unlist))
results_matrix
```

[코드 9-4] 각 세포의 세포 유형을 추정하고 이를 슈랏 오브젝트에 추가하기 
```{r}
# 세포 유형 결정 함수
determine_cell_type <- function(cluster_scores) {
  if (all(cluster_scores == 0)) {
    return('unknown')
  } else {
    return(names(which.max(cluster_scores))) # 가장 높은 점수를 갖는 세포유형 반환
  }
}

# 결과 매트릭스를 클러스터별로 세포 유형으로 변환
cluster_cell_types <- apply(results_matrix, 1, determine_cell_type)

# Seurat 객체에서 각 세포의 클러스터 정보를 가져옴
cluster_info <- pbmc_alzheimer_SCT.combined@meta.data$integrated_snn_res.0.3

# 각 세포에 세포 유형 할당
cell_types <- sapply(cluster_info, function(cluster) {
  cluster_name <- paste("Cluster", cluster)
  cluster_cell_types[[cluster_name]] # 해당 클러스터에 부여된 세포 유형 반환 
})

# Seurat 객체에 세포 유형 메타데이터 추가 (열 이름은 'cell_type')
pbmc_alzheimer_SCT.combined <- AddMetaData(pbmc_alzheimer_SCT.combined, metadata = cell_types, col.name = 'cell_type')

head(pbmc_alzheimer_SCT.combined@meta.data)
```

[코드 9-5] 마커 유전자 기반 세포 유형 주석한 UMAP 시각화
```{r}
DimPlot(pbmc_alzheimer_SCT.combined, group.by = "cell_type", reduction = "umap", label = T)
```
```{r}
saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA_UMAP_knownmarker_based_celltype.rds")
```


## 9.2 슈랏 참조 맵핑 (reference mapping) 이용하기 

먼저 참조 데이터를 다운로드 받아줍니다. 저희는 Seurat 에서 제공하는 말초 혈액 세포 참조데이터를 이용하겠습니다. https://zenodo.org/records/7779017#.ZCMojezMJqs 에서 직접 다운을 받거나 다음과 같이 R 코드로 다운받을 수 있습니다. 

[코드 9-6] 참조 데이터 슈랏 오브젝트 다운로드하기 
```{r}
# 다운받을 데이터의 URL 
url <- "https://zenodo.org/records/7779017/files/pbmc_multimodal_2023.rds?download=1"

# 파일 이름과, 저장 위치 정한 후 데이터 다운로드 받기 
file_name <- "pbmc_multimodal_2023.rds"
file_path <- "../data/"
options(timeout=300)    # 다운로드 시간 조정 (300초 = 5분)
download.file(url, paste(file_path, file_name, sep = ""), mode = "wb")

# 데이터 읽기 
pbmc_multimodal_2023 <- readRDS("../data/pbmc_multimodal_2023.rds")
DimPlot(pbmc_multimodal_2023, group.by = "celltype.l1", label = T, repel = TRUE)
DimPlot(pbmc_multimodal_2023, group.by = "celltype.l2", label = T, repel = TRUE)
```

_FindTransferAnchors()_ 을 이용해서 참조데이터와 우리 데이터의 공통된 지점인 anchors을 찾을 수 있으며, 추후, 해당 anchors와 _TransferData_ 함수를 이용해서 참조오브젝트의 데이터를 저희의 오브젝트에 옮길 수 있습니다. 

[코드 9-7] 참조 데이터를 이용한 세포유형 맵핑
```{r}
# 참조 데이터와 쿼리 데이터 간의 앵커(anchor) 찾기
anchor <- FindTransferAnchors(
  reference = pbmc_multimodal_2023,     # 주석이 완료된 참조 데이터
  query = pbmc_alzheimer_SCT.combined,  # 세포 유형을 예측하고자 하는 쿼리 데이터
  reference.assay = "SCT",              
  reference.reduction = "spca",         # Supervised PCA
  query.assay = "integrated",          
  normalization.method = "SCT",      
  dims = 1:50                         
)

# 찾은 앵커를 바탕으로 쿼리 데이터에 세포 유형 주석 전이
pbmc_alzheimer_SCT.combined <- MapQuery(
  anchorset = anchor,
  query = pbmc_alzheimer_SCT.combined,
  reference = pbmc_multimodal_2023,
  refdata = list(
    celltype.l1 = "celltype.l1",  
    celltype.l2 = "celltype.l2"),
  reduction.model = "wnn.umap"       # 참조 데이터의 UMAP 모델에 쿼리 데이터를 매핑
)
```

[코드 9-8] 슈랏 참조 매핑 결과 UMAP 시각화
```{r fig.width = 10}
# ref.umap 이용하기
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "ref.umap", group.by = "predicted.celltype.l1", label = T)
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "ref.umap", group.by = "predicted.celltype.l2", label = T)

# 원래 umap 이용하기 
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "umap", group.by = "predicted.celltype.l1", label = T)
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "umap", group.by = "predicted.celltype.l2", label = T, repel = T, label.size = 4)
```

## 9.3 외부 프로그램 이용 
### Azimuth 

[코드 9-9] Azimuth 실행 코드
```{r}
# devtools 설치 및 불러오기
install.packages("devtools") 
library(devtools) 

# Azimuth 설치 및 불러오기
devtools::install_github('satijalab/azimuth', ref = 'master')
library(Azimuth)  

# Azimuth 실행하기 
pbmc_Azimuth <- RunAzimuth(pbmc_alzheimer_SCT.combined, reference = "pbmcref") 
```

[코드 9-10] Azimuth를 이용한 참조 매핑 결과 UMAP 시각화
```{r fig.width=10}
DimPlot(pbmc_Azimuth, reduction = "umap", group.by = "predicted.celltype.l2", label = T, repel = T, label.size = 4)
```

[코드 9-11] SeuratDisk를 이용하여 h5Seurat 형식으로 저장
```{r}
# 슈랏 오브젝트를 .h5Seurat 형식으로 저장
library(SeuratDisk)
SaveH5Seurat(pbmc_alzheimer_SCT.combined, filename = "./rds/pbmc_alzheimer_SCT_CCA_UMAP_reference_mapping.h5Seurat")

# .h5Seurat 파일을 다시 슈랏 오브젝트로 불러오기
pbmc_alzheimer_SCT.combined <- LoadH5Seurat("./rds/pbmc_alzheimer_SCT_CCA_UMAP_reference_mapping.h5Seurat")
# Validating h5Seurat file
# Error: Call assays must have either a 'counts' or 'data' slot, missing for RNA
```


### SingleR
MonacoImmuneData는 벌크 RNA 시퀀싱에서 나온 면역 세포의 다양한 유형을 모아놓은 데이터 입니다. 따라서 여러 유형의 면역 세포가 포함되어서 말초혈액 단핵세포 데이터를 분석하는 데 가장 적합합니다. 

```{r}
BiocManager::install(
  BiocManager::valid()$out_of_date,
  update = TRUE,
  ask = FALSE,
  force = TRUE
)
```


[코드 9-11] SingleR을 이용한 주석에 필요한 라이브러리 설치하기 
```{r}
BiocManager::install("celldex")
BiocManager::install("SingleR") 
BiocManager::install("SingleCellExperiment") 
```

[코드 9-12]  SingleR을 이용한 세포 유형 주석 실행 및 시각화
```{r, fig.width=10}
# 패키지 불러오기 
library(SingleR) 
library(celldex) 
library(SingleCellExperiment) 

# 비슷한 참조 데이터 불러오기 
ref.data <- MonacoImmuneData(ensembl=F)

# singleR 과 호환 가능한 singleCellExperiment(sce) 유형으로 변환하기 
sobj_SCE <- as.SingleCellExperiment(pbmc_alzheimer_SCT.combined, assay="SCT")
results <- SingleR(test = sobj_SCE, ref = ref.data, labels = ref.data$label.main) 

# 추측된 세포 유형 주석 데이터 추가하기 
pbmc_alzheimer_SCT.combined$MonacoImmuneData_main <- results$labels

# UMAP 시각화 
# 메인 주석
Idents(pbmc_alzheimer_SCT.combined) <- pbmc_alzheimer_SCT.combined$MonacoImmuneData_main 
DimPlot(pbmc_alzheimer_SCT.combined, label = T, reduction = "umap") 

# 각 클러스터별 주석 점수 힛맵
tab <- table(cluster = pbmc_alzheimer_SCT.combined$integrated_snn_res.0.3, label = results$labels)
pheatmap::pheatmap(log10(tab+10), cluster_cols = FALSE)
```


### scType

[코드 9-13] scType에 필요한 툴과 데이터 다운로드하기 
```{r}
# 필요한 라이브러리 설치 및 불러오기  
BiocManager::install("HGNChelper")
install.packages("openxlsx")
library(HGNChelper)      # 유전자 이름 표준화 도구
library(openxlsx)        # 엑셀 파일 다루기 

# scType 함수 불러오기 
# 유전자 마커 목록을 준비하는 함수 (gene_sets_prepare) 불러오기
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# 실제 세포 유형 점수를 계산하는 함수 (sctype_score_) 불러오기
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

# 사용할 유전자 마커 데이터베이스 파일 지정 (혹은 직접 만들어 사용 가능합니다.) 
db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx"

# 분석할 조직(tissue) 선택
# 예: Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus
tissue = "Immune system"  

# 선택한 조직에 해당하는 마커 유전자 리스트 불러오기
gs_list = gene_sets_prepare(db_, tissue)
```

[코드 9-13] scType를 이용한 세포유형 맵핑
```{r}
# 유전자 발현 데이터를 기반으로 세포 유형 점수 계산
# gs: 양성 마커 유전자 리스트 / gs2: 음성 마커 유전자 리스트
es.max = sctype_score(
  scRNAseqData = pbmc_alzheimer_SCT.combined[["integrated"]]@scale.data, 
  scaled = TRUE,  
  gs = gs_list$gs_positive, 
  gs2 = gs_list$gs_negative
)

# 각 클러스터 별로 세포 유형 점수 합산하여 정리
cL_results = do.call("rbind", lapply(
  unique(pbmc_alzheimer_SCT.combined@meta.data$integrated_snn_res.0.3), 
  function(cl) {
    # 해당 클러스터에 속한 셀들만 필터링한 후, 유사도 점수 합산
    es.max.cl = sort(
      rowSums(es.max[ , rownames(pbmc_alzheimer_SCT.combined@meta.data[
        pbmc_alzheimer_SCT.combined@meta.data$integrated_snn_res.0.3 == cl, ])]), 
      decreasing = TRUE
    )
    
    # 상위 10개 세포 유형에 대한 점수, 클러스터 정보와 함께 데이터 프레임으로 저장
    head(data.frame(
      cluster = cl, 
      type = names(es.max.cl), 
      scores = es.max.cl, 
      ncells = sum(pbmc_alzheimer_SCT.combined@meta.data$integrated_snn_res.0.3 == cl)
    ), 10)
  }
))

# 각 클러스터에서 점수가 가장 높은 세포 유형을 선택
sctype_scores = cL_results %>%
  group_by(cluster) %>%
  top_n(n = 1, wt = scores)

# 클러스터 내 셀 수 대비 ScType 점수가 낮은 경우, 'Unknown'으로 주석
sctype_scores$type[
  as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells / 4
] = "Unknown"
```

[코드 9-14] scType를 이용한 세포유형 맵핑 시각화 
```{r fig.width = 10}
# 각 클러스터에 대해 가장 높은 점수를 받은 세포 유형을 'customclassif' 열에 할당 
# pbmc_alzheimer_SCT.combined@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]
  pbmc_alzheimer_SCT.combined@meta.data$customclassif[pbmc_alzheimer_SCT.combined@meta.data$integrated_snn_res.0.3 == j] = as.character(cl_type$type[1])
}

saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA_UMAP_scType.rds")
```

[코드 9-13] scType를 이용한 세포유형 맵핑 시각화
```{r  fig.width=10}
DimPlot(pbmc_alzheimer_SCT.combined, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'customclassif') 
```


```{r}
# 함수 불러오기
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/auto_detect_tissue_type.R")
db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

# 조직 유형 유추하기
tissue_guess = auto_detect_tissue_type(path_to_db_file = db_, seuratObject = pbmc_alzheimer_SCT.combined, scaled = TRUE, assay = "SCT") 
# assay = "integrated"
# Error in h(simpleError(msg, call)) : 
#   error in evaluating the argument 'x' in selecting a method for function 'rowSums': incorrect number of
```

### scanVI
[코드 9-] scanVI 를 위한 라이브러리 설치 및 Seurat 오브젝트 변환 
```{r}
install.packages("reticulate") # python함수를 R에서 사용가능하게 도와주는 라이브러리 (TODO : 체크 하기) 
install.packages("cowplot")    # ggplot를 활용한 시각화를 도와주는 툴 
# install.packages("devtools")   # CRAN뿐 아니라 github, bioconductor 등에서도 쉽게 라이브러리를 설치 할 수 있도록 도와주는 툴 
library(devtools)
devtools::install_github("cellgeni/sceasy")
library(reticulate)
library(cowplot)
library(sceasy)

# Seurat 오브젝트를 AnnData 오브젝트로 변형하기 
sc <- import("scanpy", convert = FALSE)
scvi <- import("scvi", convert = FALSE)
adata <- convertFormat(pbmc_alzheimer_SCT.combined, from="seurat", to="anndata", main_layer="counts", drop_single_values=FALSE)
print(adata) # Note generally in Python, dataset conventions are obs x var
```

# 챕터 10 단일 세포 데이터 후속 분석 
## 챕터 10.1 차등 발현 유전자 분석  

```{r}
pbmc_alzheimer_SCT.combined <- readRDS("./rds/pbmc_alzheimer_SCT_CCA_UMAP_scType.rds") 

# pbmc_alzheimer_SCT.combined@meta.data <- pbmc_alzheimer_SCT.combined@meta.data %>%
#   select(1:10, 12:14, 11)
# saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA_UMAP_scType.rds")
# 

# pbmc_alzheimer_SCT.combined[[]] <- pbmc_alzheimer_SCT.combined[[]] %>%
  # mutate(customclassif = gsub(" |  ", "_", customclassif))
```

```{r}
devtools::install_github('immunogenomics/presto')
library(presto) # for a much faster way 1
```

[코드 10-1] 그룹간 차등 유전자 발현(DEG) 분석 실행하기 
```{r}
# 그룹 식별자 설정
Idents(pbmc_alzheimer_SCT.combined) <- "subject_status"

# FindMarkers() 함수 실행 전에 준비시키기 
pbmc_alzheimer_SCT.combined<-PrepSCTFindMarkers(pbmc_alzheimer_SCT.combined) 

# 중증 환자 vs 일반인 차등 발현 유전자 
degs_severeADvsnormal <- FindMarkers(pbmc_alzheimer_SCT.combined, ident.1 = "patient with severe AD", ident.2 = "normal individual", only.pos = FALSE) 

# 경증 환자 vs 일반인 차등 발현 유전자 
degs_mildADvsnormal <- FindMarkers(pbmc_alzheimer_SCT.combined, ident.1 = "patient with mild AD", ident.2 = "normal individual", only.pos = FALSE) 

# avg_log2FC 절댓값으로 내림차순 정렬하기 
degs_severeADvsnormal <- degs_severeADvsnormal %>% 
  arrange(-abs(avg_log2FC)) 
degs_mildADvsnormal <- degs_mildADvsnormal %>% 
  arrange(-abs(avg_log2FC)) 
```

[코드 10-2] 데이터 프레임 csv 형태로 저장하기  
```{r}
write.csv(degs_severeADvsnormal, "../results/all_degs_severeADvsnormal.csv", row.names=F) 
write.csv(degs_mildADvsnormal, "../results/all_degs_mildADvsnormal.csv", row.names=F) 
```


[코드 10-3] 차등 발현 유전자 시각화 - 바이올린 플롯 
```{r fig.height=10}
# 설정
Idents(pbmc_alzheimer_SCT.combined) <- "subject_status"
DefaultAssay(pbmc_alzheimer_SCT.combined) <- "SCT"

# 차등 발현이 가장 큰 유전자 6개의 바이올린 플롯 
VlnPlot(pbmc_alzheimer_SCT.combined, features = rownames(degs_severeADvsnormal)[1:6],
        layer = "data", log = TRUE)
```

[코드 10-4] 차등 발현 유전자 시각화 - 릿지 플롯 
```{r fig.height=10}
RidgePlot(pbmc_alzheimer_SCT.combined, features = rownames(degs_severeADvsnormal)[1:6],
        layer = "data")
```

[코드 10-5] 차등 발현 유전자 시각화 - 피쳐 플롯 
```{r fig.height=10}
FeaturePlot(pbmc_alzheimer_SCT.combined, features = rownames(degs_severeADvsnormal)[1:2], split.by = "subject_status")
```

[코드 10-6] 세포 유형별 차등 발현 유전자(DEG) 분석 
```{r}
# 설정 
Idents(pbmc_alzheimer_SCT.combined) <- "subject_status" 
DefaultAssay(pbmc_alzheimer_SCT.combined) <- "SCT"

# 세포 유형별 차등 발현 유전자(DEG) 알아내기  
for (celltype in unique(pbmc_alzheimer_SCT.combined@meta.data$customclassif)){
  # 현재 분석 중인 세포 유형 출력
  print(glue::glue("### {celltype} is processing ...")) 
  
  ## 중증 환자 vs 일반인  
  degs_severeADvsnormal <- FindMarkers(pbmc_alzheimer_SCT.combined, 
                                       ident.1 = "patient with severe AD", 
                                       ident.2 = "normal individual",
                                       subset.ident = celltype, only.pos = FALSE)
  
  ## 경증 환자 vs 일반인  
  degs_mildADvsnormal <- FindMarkers(pbmc_alzheimer_SCT.combined, 
                                     ident.1 = "patient with mild AD", 
                                     ident.2 = "normal individual", 
                                     subset.ident = celltype,, only.pos = FALSE) 

  ## 결과를 CSV 파일로 저장 
  write.csv(degs_severeADvsnormal, glue::glue( "../results/{celltype}_degs_severeADvsnormal.csv"), row.names = T)
  write.csv(degs_mildADvsnormal, glue::glue( "../results/{celltype}_degs_mildADvsnormal.csv"), row.names = T)
  
}

# TODO: 왜,,,, 이렇게 하니까 아웃풋이 다른것 같지 
saveRDS(pbmc_alzheimer_SCT.combined, "./rds/pbmc_alzheimer_SCT_CCA_UMAP_scType_prepSCT.rds")
```
```{r}
# 설정 
Idents(pbmc_alzheimer_SCT.combined) <- "subject_status" 

# 세포 유형별 차등 발현 유전자(DEG) 분석 함수 
run_DEGs_per_celltype <- function(seurat_obj, celltype) { 
  ## 특정 세포 유형으로만 이루어진 슈랏 오브젝트 부분 추출하기 
  sobj_sub <- subset(x = seurat_obj, subset = customclassif == celltype) 

  ## 중증 환자 vs 일반인  
  degs_severeADvsnormal <- FindMarkers(seurat_obj, ident.1 = "patient with severe AD", ident.2 = "normal individual", only.pos = FALSE) %>% 
    arrange(-(avg_log2FC)) 
  
  ## 경증 환자 vs 일반인  
  degs_mildADvsnormal <- FindMarkers(seurat_obj, ident.1 = "patient with mild AD", ident.2 = "normal individual", only.pos = FALSE) %>% 
    arrange(-(avg_log2FC)) 

  ## 차등 발현 유전자 CSV 파일로 저장하기  
  write.csv(degs_severeADvsnormal, glue::glue( "./results/{celltype}_degs_severeADvsnormal.csv"), row.names = T)
  write.csv(degs_mildADvsnormal, glue::glue( "./results/{celltype}_degs_mildADvsnormal.csv"), row.names = T)

  return(sobj_sub) 
} 


# 각 세포유형 마다 실행하기  
sobj_subsets_list <- list() 

for (celltype in unique(pbmc_alzheimer_SCT.combined$customclassif)){ 
  print(glue::glue("### {celltype} is processing ... ")) 
  sobj_subset <- run_DEGs_per_celltype(pbmc_alzheimer_SCT.combined, celltype) 
  
  ## 부분 추출 된 슈랏 오브젝트들을 리스트에 추가하기   
  sobj_subsets_list[[celltype]] <- sobj_subset 
} 

# 후속 분속에 이용하기 위하여 저장하기  
# saveRDS(sobj_subsets_list, "./rds/sobj_subsets_list.rds")
sobj_subsets_list <- readRDS("./rds/sobj_subsets_list.rds")
```


[코드 10-7] B 세포의 차등 발현 유전자 데이터 확인하기 
```{r}
# B 세포의 차등 발현 유전자 데이터 확인하기   
degs_bcell <- read.csv("../results/Naive B cells_degs_severeADvsnormal.csv", stringsAsFactors = FALSE)

# 상향 조절 유전자 들여다보기 
degs_bcell_up <- degs_bcell %>% 
  arrange(desc(avg_log2FC)) %>%             # log2FC가 큰 순서대로 정렬
  filter(p_val_adj < 0.05 & avg_log2FC > 0)  # 유의미한(p < 0.05), log2FC > 0인 유전자 필터링

# 하양 조절 유전자 들여다보기
degs_bcell_down <- degs_bcell %>% 
  arrange(desc(abs(avg_log2FC))) %>%  
  filter(p_val_adj < 0.05 & avg_log2FC < 0) 
```

[코드 10-8] B 세포의 차등 발현 유전자 발현 패턴 시각화: 히트맵 
```{r, fig.width = 10}
# 1. log2FC 큰 상위 200개 유전자만 선택
top_genes <- degs_bcell %>% 
  filter(p_val_adj < 0.05 ) %>%
  arrange(desc(abs(avg_log2FC))) %>% 
  head(100)

selected_genes <- top_genes$X

# 2. 평균값 매트릭스 가져오기
# TODO: group_means
group_means_matrix_sub <- group_means$SCT[selected_genes, ]

# 3. pheatmap 그리기
pheatmap(group_means_matrix_sub,  
         cluster_rows = TRUE,       # 유전자 클러스터링 추가
         cluster_cols = FALSE, 
         show_rownames = FALSE, 
         show_colnames = TRUE,
         angle_col = 0,
         scale = "row", 
         main = "Naive B Cell DEGs (Top 100)",
         breaks = seq(-1, 1, length.out = 101),
         color = colorRampPalette(c("blue", "white", "red"))(100))

```

[코드 10-9] B 세포에서의 차등 발현 유전자 박스 플롯 그리기 
```{r, fig.width = 12}
# pbmc_naive_bcell <- subset(pbmc_alzheimer_SCT.combined, subset = customclassif == "Naive B cells")
pbmc_naive_bcell <- sobj_subsets_list$`Naive B cells`
pbmc_naive_bcell
# DefaultAssay(sobj_bcell) <- "SCT"edw

# degs_bcell_up_ <- degs_bcell_up %>% filter(pct.1 - pct.2 > 0.2)
RidgePlot(pbmc_naive_bcell, features = degs_bcell_up[1:6, ]$X, ncol = 2, layer = "data", log = TRUE)

degs_bcell_up[degs_bcell$X == "RPS4Y1",]

RidgePlot(pbmc_naive_bcell, features = c("RPS4Y1", ), ncol = 2, layer = "data", log = TRUE)

VlnPlot(pbmc_naive_bcell, features = degs_bcell_up[1:6, ]$X, layer = "data", log = TRUE)
```

## 챕터 10.2 하위클러스터링 
[코드 10-11] B 세포 재클러스터링  
pbmc_alzheimer_SCT.combined@graphs$integrated_nn 
(nn: kNN graph , snn: shared NN graph)
```{r }
# [1] 원래 데이터 이용하기 
Idents(pbmc_alzheimer_SCT.combined) <- "customclassif"
pbmc_alzheimer_SCT.combined <- FindSubCluster(
  pbmc_alzheimer_SCT.combined,
  "Naive B cells",
  graph.name = "integrated_nn",
  subcluster.name = "sub.cluster",
  resolution = 0.3,
  algorithm = 1
)

# 시각화 
DimPlot(pbmc_alzheimer_SCT.combined, group.by = "sub.cluster")


# [2] B 세포 부분 데이터 이용하기 
pbmc_bcells <- sobj_subsets_list$`Naive B cells`
pbmc_bcells <- FindClusters(pbmc_bcells, resolution = 0.3, graph.name ="integrated_nn", cluster.name = "Naive B Cells subclusters") 

# 시각화 
DimPlot(pbmc_bcells, group.by = "Naive B Cells subclusters") 
colnames(pbmc_bcells[[]])
```

## 챕터 10.3 샘플간의 거리 시각화

[코드 10-12] 단일 세포 데이터를 주성분 분석 그래프로 나타내기 
```{r}
# 슈랏 오브젝트에서 Run별 평균 유전자 발현값 계산하기
Idents(pbmc_alzheimer_SCT.combined) <- "Run"
pbmc_alzhemier_avg_expr <- AverageExpression(object = pbmc_alzheimer_SCT.combined, assays = "SCT")

# 결과를 데이터프레임 형태로 변환하기
pbmc_alzhemier_avg_expr <- as.data.frame(t(pbmc_alzhemier_avg_expr$SCT))

# 평균 발현값을 이용해 주성분 분석(PCA) 수행하기
pbmc_alzhemier_avg_expr_pca <- prcomp(pbmc_alzhemier_avg_expr, center = TRUE, scale = TRUE)

# ggbiplot 패키지를 이용해 PCA 결과 시각화 (샘플 상태별 색상 구분)
install.packages("ggbiplot")
library(ggbiplot)
sample_groups <- unique(pbmc_alzheimer_SCT.combined@meta.data[, c("Run", "subject_status")])$subject_status # 샘플 이름(Run)별 subject_status 정보를 가져와서 색 지정하기
ggbiplot(pbmc_alzhemier_avg_expr_pca,
         labels = row.names(pbmc_alzhemier_avg_expr),
         var.axes = FALSE,
         groups = sample_groups)
```

## 챕터 10.4 GSEA and KEGG 경로 분석 
[코드 10-13] GSEA에 필요한 패키지 설치 및 라이브러리 불러오기 
```{r}
# GSEA 분석에 필요한 패키지 불러오기 
BiocManager::install("msigdbr")
library(msigdbr) 	#위에서 언급한 분자특성데이터베이스를 R에서 불러오는 패키지 
BiocManager::install("fgsea")
library(fgsea)
library(dplyr)  
library(ggplot2)  
library(tidyverse)  
library(data.table) 
```

[코드 10-14] B세포 차등발현 유전자 확인하기 
```{r}
head(degs_bcell_0.05) 
```

[코드 10-15] 유전자 그룹 데이터베이스 불러와 정리하기
```{r}
# 사용 가능한 생물 종 모두 표시하기 
# msigdbr_species()  

#분자특성데이터베이스에서 유전자 그룹 불러오기 
m_df<- msigdbr(species = "Homo sapiens", category = "H") 

#불러온 유전자 그룹 정리하기 
fgsea_sets<- m_df %>% split(x = .$gene_symbol, f = .$gs_name)  

#불러온 유전자 그룹 살펴보기  
head(m_df) 
```

```{r}
# 유전자를 발현량 차이로 정렬하여 순서대로 저장하기 
Bcell.genes <- degs_bcell_0.05 %>% arrange(desc(avg_log2FC)) %>% dplyr::select(X, avg_log2FC) 
head(Bcell.genes) 

ranks<- deframe(Bcell.genes)  
head(ranks) 
```

```{r}
# GSEA 실행하여 저장하기 
fgseaRes<- fgsea(fgsea_sets, stats = ranks, nperm = 1000) 

# 필요한 정보를 보기쉽게 저장하기 
fgseaResTidy <- fgseaRes %>% as_tibble() %>% arrange(desc(NES)) 
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% arrange(padj) 
head() 
```
```{r}
ggplot(fgseaResTidy %>% head(n= 50), aes(reorder(pathway, NES), NES)) +   
  geom_col(aes(fill= NES<0)) + 
  coord_flip() + 
  labs(x="Pathway", y="Normalized Enrichment Score", title="Hallmark pathways NES from GSEA") + 
  theme_minimal() 
```

```{r}
plotEnrichment(fgsea_sets[["HALLMARK_INTERFERON_ALPHA_RESPONSE"]], ranks) + 
  labs(title="HALLMARK_ INTERFERON_ALPHA_RESPONSE ") 
```

Time series
```{r, fig.width = 12}
DimPlot(pbmc_alzheimer_SCT.combined, split.by = "subject_status", group.by = "customclassif", label.size = 2) + 
  theme(legend.text = element_text(size = 8))
```


# 챕터 11 추가 분석 툴들 
## 11.1 품질 관리(QC)
### 11.1.1 두방울 세포 제거
#### DoubletFinder

[코드 11-1] 슈랏 오브젝트에 Doubletfinder 함수 실행하기 
```{r}
# DoubleFinder 설치 및 불러오기 
install.packages("remotes")
remotes::install_github('chris-mcginnis-ucsf/DoubletFinder')
library(DoubletFinder)

# pbmc_alzheimer_SCT.list 파일 불러오기
pbmc_alzheimer_SCT.list <- readRDS("./rds/pbmc_alzheimer_SCT.list.rds")

# 각 샘플마다 최근접 이웃 (NN) 찾기 및 SNN 그래프 구축 
pbmc_alzheimer_SCT.list_processed <- lapply(pbmc_alzheimer_SCT.list, function(sobj) {  
    sobj <- sobj %>%  
      SCTransform(.,verbose = FALSE) %>%
      RunPCA(., verbose = FALSE) %>%
      RunUMAP(., reduction = "pca", dims = 1:30, verbose = FALSE) %>%
      FindNeighbors(., reduction = "pca", dims = 1:30) %>% 
      FindClusters(., resolution = c(0.3)) 
}) 

# 각 샘플마다 두 세포 방울 찾기  
pbmc_alzheimer_SCT.list_processed_doublefinder <- lapply(pbmc_alzheimer_SCT.list_processed, function(sobj) {  
  # 예시로 전체 세포의 7.5%를 예상 두방울 수로 설정
  nExp_poi <- round(0.075 * nrow(sobj@meta.data))
  # DoubletFinder 실행 
  sobj_doublefinder <- doubletFinder(sobj, PCs = 1:10, pN = 0.25, pK = 0.09, nExp = nExp_poi, reuse.pANN = FALSE, sct = TRUE) 
})
```

[코드 11-2] DoubletFinder의 pK 매개변수 최적 값 구하기
```{r}
# 불러온 슈랏 오브젝트 내의 SCT 모델을 통합시켜 준비시키기
pbmc_alzheimer_SCT.combined<-PrepSCTFindMarkers(pbmc_alzheimer_SCT.combined)

sweep.list <- paramSweep(pbmc_alzheimer_SCT.combined, PCs=1:10, sct=TRUE)
sweep.stats <- summarizeSweep(sweep.list, GT=FALSE)
bcmvn <- find.pK(sweep.stats)
```

```{r}
# DoubletFinder 결과 확인 
pbmc_alzheimer_SCT.list_processed_doublefinder[[1]]@meta.data[1:5,]
```

[코드 11-3] DoubletFinder 실행 결과 시각화 예시 
```{r}
DimPlot(pbmc_alzheimer_SCT.list_processed_doublefinder[[1]],  group.by = "DF.classifications_0.25_0.09_860") 
```

```{r}
# pbmc_alzheimer_SCT.list_processed_doublefinder[[1]] <- subset(pbmc_alzheimer_SCT.list_processed_doublefinder[[1]], subset = DF.classifications_0.25_0.09_860 == "Singlet")
# # TODO 
```

[코드 11-4] DoubletFinder 실행 결과들을 통합 슈랏 오브젝트 메타데이터에 추가하기
```{r}
# pbmc_alzheimer_SCT.list_processed_doublefinder의 여섯 개의 결과값을 추출하여 통합 오브젝트(pbmc_alzheimer_SCT.combined)에 합치기  
for (i in 1:length(pbmc_alzheimer_SCT.list_processed_doublefinder)) { 
  current_object <- pbmc_alzheimer_SCT.list_processed_doublefinder[[i]] 
   
  # DoubletFinder 실행 결과인 스코어와 두 방울 결과 값 열 추출 
  current_metadata <- current_object@meta.data[, 9:10] 
  print(dim(current_metadata)) 
   
  # 열 이름을 통일성 있게 변경하기 
  colnames(current_metadata) <- c("DF.score", "DF.classifications") 
   
  # 통합 오브젝트와 일치하는 세포 바코드 찾기 
  common_cells <- intersect(rownames(pbmc_alzheimer_SCT.combined@meta.data), paste0(rownames(current_metadata), "_", i)) 
   
  # DoubletFinder 결과값들을 pbmc_alzheimer_SCT.combined 오브젝트의 메타데이터에 추가 
  pbmc_alzheimer_SCT.combined@meta.data[common_cells, "DF.score"] <- current_metadata[rownames(current_metadata), "DF.score"] 
  pbmc_alzheimer_S 
}
# TODO 

# 업데이트 된 메타데이터 확인해보기 (마지막 두개 열을 확인해보세요) 
head(pbmc_alzheimer_SCT.combined@meta.data)
```


#### scDblFinder
[코드 11-5] 슈랏 오브젝트에 scDblFinder함수 실행하기 
```{r}
# scDBlFinder 패키지 설치 및 불러오기
BiocManager::install("scDblFinder")
library(scDblFinder)

# 방법 1. 각 샘플마다 두 세포 방울 계산  
pbmc_alzheimer_SCT.list_processed_sce <- lapply(pbmc_alzheimer_SCT.list_processed, function(sobj) {  
  # 슈랏 오브젝트를 singlecellexperiment(sce) 오브젝트로 변환하기
  sce <- as.SingleCellExperiment(sobj)
  # scDblFinder 실행 
  sce_scDblFinder <- scDblFinder(sce)
})
 
# 방법 2. 합쳐진 슈랏 오브젝트를 이용하여 두 세포 방울 한번에 계산  
sce <- as.SingleCellExperiment(pbmc_alzheimer_SCT.combined, assay = "SCT")
sce_scDblFinder <- scDblFinder(sce, samples = "Run") 
head(colData(sce_scDblFinder))
```


### 11.1.2 세포 잔해 제거
#### SoupX
[코드 11-6] SoupX를 이용하여 주변 RNA 계산하기
```{r}
# SoupX 패키지 설치 및 불러오기
install.packages("SoupX") 
library(SoupX) 

# 미가공 데이터 불러오기 
sc = load10X("../data/count_SRR13911909/outs/")

# 오염 정도(rho) 추정
sc = autoEstCont(sc)
sc$metaData    # 메타데이터 및 오염 정도 확인 
sc$soupProfile # 주변 RNA로 추측된 유전자 카운트 확인 

# 데이터 정제
out = adjustCounts(sc)

# 시각화 예시
plotChangeMap(sc, out, "ISG15")
```

#### DecontX 
[코드 11-7] DecontX를 이용하여 주변 RNA 제거하기 
```{r}
# decontX 설치 및 불러오기 
BiocManager::install("decontX")
library(decontX)

# 슈랏 오브젝트에서 sce 오브젝트로 전환 
sce <- as.SingleCellExperiment(pbmc_alzheimer_SCT.combined, assay = "SCT")

# decontX 실행 
sce <- decontX(sce) # add background? 

# 결과 확인 
colData(sobj_SCE)

# 시각화 예시  
plotDecontXContamination(sce)
```

[코드 11-9] 통합 데이터에 decontX 결과값 추가 
```{r}
pbmc_alzheimer_SCT.combined[["decontXcounts"]] <- CreateAssayObject(counts = decontXcounts(sce))
```


# 11.2 클러스터링 최적의 해상도 선택 
[코드 11-10] 현재 슈랏 오브젝트에 클러스트리 실행
```{r}
# 클러스트리 설치하고 불러오기
BiocManager::install("clustree")
library(clustree)

# 클러스트리 실행하기
clustree(pbmc_alzheimer_SCT.combined, prefix = "integrated_snn_res.")
```

[코드 11-11] 더 많은 해상도를 이용하여 클러스터링 및 클러스터리 실행
```{r}
# 슈랏 오브젝트 준비시키기
DefaultAssay(pbmc_alzheimer_SCT.combined) <- "integrated"

# 더 많은 해상도를 이용하여 클러스터링 하기
pbmc_alzheimer_SCT.combined <- FindClusters(pbmc_alzheimer_SCT.combined, resolution = c(0.15, 0.25, 0.35, 0.4, 0.45))

# 클러스트리 실행하기
clustree(pbmc_alzheimer_SCT.combined, prefix = "integrated_snn_res.")
```


## 11.3 유전자 네트워크 분석
### hdWGCNA
[코드 11-12] hdWGCNA 실행에 필요한 라이브러리 설치 및 불러오기 
```{r}
# 필요한 패키지 설치 및 불러오기  
BiocManager::install(c("WGCNA", "igraph", "devtools", "GeneOverlap", "ggrepel", "UCell")) 
devtools::install_github("NightingaleHealth/ggforestplot") 
devtools::install_github('smorabit/hdWGCNA', ref='dev') 
library(WGCNA) 
library(hdWGCNA) 
library(cowplot) 
library(patchwork) 

# 시각화 테마 및 다중 프로세서 설정하기 
theme_set(theme_cowplot()) 
allowWGCNAThreads() 
```

[코드 11-13] hdWGCNA을 이용한 네트워크 분석 1
```{r}
# 슈랏 오브젝트 불러오기와 설정하기
pbmc_sample1 <- Read10X_h5("SRR13911909_filtered_feature_bc_matrix.h5")
pbmc_sample1 <- CreateSeuratObject(counts = pbmc_sample1, project = "AD1", min.cells = 3, min.features = 200)
pbmc_sample1 <- NormalizeData(pbmc_sample1)
pbmc_sample1 <- FindVariableFeatures(pbmc_sample1)
all.genes <- rownames(pbmc_sample1)
pbmc_sample1 <- ScaleData(pbmc_sample1, features = all.genes)
pbmc_sample1 <- RunPCA(pbmc_sample1)
pbmc_sample1 <- FindNeighbors(pbmc_sample1, dims = 1:10)
pbmc_sample1 <- FindClusters(pbmc_sample1, resolution = 0.5)

# 설정한 슈랏 오브젝트를 WGCNA 실행 준비시키기
pbmc_sample1 <- SetupForWGCNA(
  pbmc_sample1,
  gene_select = "fraction", # 유전자 선택 방법
  fraction = 0.05, # 유전자가 발현된 세포의 비율 최솟값
  wgcna_name = "pbmc_hdwgcna" # 임의로 설정한 hdWGCNA 이름
) 
 
# 메타셀로 불리는 유전자 발현에 따른 세포 그룹 형성하기
pbmc_sample1 <- MetacellsByGroups(
  seurat_obj = pbmc_sample1,
  group.by = c("seurat_clusters"), # 그룹을 형성할 메타데이터 선택하기
  reduction = 'pca', # KNN을 실행할 차원축소 방법 설정하기
  k = 25, # KNN 매개변수 설정하기
  max_shared = 15, # 두 메타셀 간의 최대 공통 세포 갯수 정하기
  ident.group = 'seurat_clusters' # 슈랏 오브젝트의 idents 설정하기
)

# 메타셀 발현 매트릭스 정규화하기
pbmc_sample1 <- NormalizeMetacells(pbmc_sample1)
 
# 유전자 발현 매트릭스 설정하기
pbmc_sample1 <- SetDatExpr(
  pbmc_sample1,
  group_name = "0", # group.by에 속해있는 관심 세포 유형 설정하기
  group.by='seurat_clusters', # MetacellsByGroups에 사용된 세포 유형 정보를 포함한 그룹 이름
  assay = 'RNA',
  slot = 'data'
)
 
# 소프트파워 값 설정하기
pbmc_sample1 <- TestSoftPowers(
  pbmc_sample1,
  networkType = 'signed'
)

# 소프트파워 값 시각화하기
plot_list <- PlotSoftPowers(pbmc_sample1)
wrap_plots(plot_list, ncol=2)
```

[코드 11-15] hdWGCNA을 이용한 네트워크 분석 2
```{r}
# 공통발현 네트워크 구축하기
pbmc_sample1 <- ConstructNetwork(
  pbmc_sample1, 
   soft_power = 4, # [그림 11-9]에서 선택한 소프트파워 값 4
   overwrite_tom = TRUE
) 

# 모듈 고유 유전자 및 연결정도 계산하기
pbmc_sample1 <- ModuleEigengenes(
  pbmc_sample1
)

pbmc_sample1 <- ModuleConnectivity(
  pbmc_sample1,
  group.by = 'seurat_clusters', group_name = '0'
)
 
# 각 모듈 별 유전자 연결 시각화하여 저장하기
ModuleNetworkPlot(
  pbmc_alzheimer_SCT.combined,
  outdir = 'ModuleNetworks'  # 시각화 파일 저장 경로 지정하기
)
```


### SCENIC
- https://pyscenic.readthedocs.io/en/latest/
- https://htmlpreview.github.io/?https://github.com/aertslab/SCENIC/blob/master/Tutorials_JupyterNotebooks/SCENIC_tutorial_1-RunningVSN.html 

## 11.4 궤적 및 가상 시간 분석 
### slingshot
[코드 11-16] Slingshot 을 이용한 궤적 및 가상 시간 분석 
```{r}
# TODO Slinghot 
# 필요한 패키지 설치 및 불러오기 
BiocManager::install("kstreet13/slingshot")
library(slingshot)
library(scater) # 단일 세포 데이터 시각용 
library(Seurat)

# 슈랏 오브젝트를 singleCellExperiment 객체로 데이터 변환 
pbmc_alzheimer_SCT.combined <- readRDS("./rds/pbmc_alzheimer_SCT.combined_scTYPE_metadata.rds")
sce <- as.SingleCellExperiment(pbmc_alzheimer_SCT.combined, assay = "SCT")
# slingshot 궤적 분석 
sce.sling <- slingshot(sce, ster = sce@colData$integrated_snn_res.0.3, reducedDim='PCA')
# 계산된 가상 시간 데이터 확인 
head(sce.sling$slingPseudotime_1)

# UMAP 차원 축소에서 곡선 임베딩 
embedded <- embedCurves(sce.sling, "UMAP")
embedded <- slingCurves(embedded)[[1]] # only 1 path.
embedded <- data.frame(embedded$s[embedded$ord,])

# UMAP에 가상시간값을 색상으로 표현하고 궤적 곡선 추가 
plotUMAP(sce.sling, colour_by="slingPseudotime_1") +
    geom_path(data=embedded, aes(x=umap_1, y=umap_2), size=1.2)
```

```{r}

```


### Monocle3 
[코드 11-] Monocle3를 이용한 궤적 분석 
```{r}
# 필요한 패키지 설치 및 불러오기 
remotes::install_github('satijalab/seurat-wrappers')
devtools::install_github('cole-trapnell-lab/monocle3')
library(monocle3)
library(SeuratWrappers)

# 슈랏 오브젝트를 CellDataSet 으로 변환하기 
cds <- as.cell_data_set(pbmc_alzheimer_SCT.combined) 
# 클러스터링 
cds <- ster_cells(cds = cds, reduction_method = "UMAP")
# 궤적 분석 실행 
cds <- learn_graph(cds, use_partition = TRUE)

# 시각화 
plot_cells(cds, 
           color_cells_by = "customclassif", 
           label_groups_by_ster=FALSE, 
           label_leaves=FALSE, 
           label_branch_points=FALSE) 
```


## 11.5 세포 간 소통 
### LIANA
[코드 11-13 LIANA 실행 코드
```{r}
# LIANA 설치하기 
remotes::install_github('saezlab/liana') 

# 필요한 패키지 불러오기  
library(tidyverse) 
library(magrittr) 
library(liana) 
library(Seurat)

# 슈랏 오브젝트 데이터 불러오기 
# pbmc <- readRDS("pbmc_alzheimer_SCT.combined.rds") 
pbmc_alzheimer_SCT.combined <- readRDS("./rds/pbmc_alzheimer_SCT.combined_3500_scTYPE_metadata.rds")
DefaultAssay(pbmc_alzheimer_SCT.combined)<-"SCT" 
Idents(pbmc_alzheimer_SCT.combined) <- "customclassif" 

# LIANA 실행 및 결과 확인  
liana_test <- liana_wrap(pbmc_alzheimer_SCT.combined) 
```

[코드 11-14] LIANA 실행한 종합 순위  
```{r}
# 모든 알고리즘 결과 종합하여 나타내기 
liana_test <- liana_test %>% 
  liana_aggregate() 
```

[코드 11-15] LIANA 결과 도트 플롯으로 시각화하기 
```{r fig.wdith=10, fig.height=8}
# LIANA 결과 시각화, 도트 플롯
unique(liana_test$source)

liana_test %>% 
  liana_dotplot(source_groups = c("Naive CD4+ T cells"), 
                target_groups = c("Naive CD4+ T cells", "Naive CD8+ T cells"), 
                ntop = 20) 
```

### scriabin
[코드 11-1] scriabin을 이용한 세포간 소통 상호작용 분석 
```{r}
# 필요한 설치 및 불러오기 
BiocManager::install("CelliD") 
devtools::install_github("BlishLab/scriabin", ref = "main") 
library(scriabin) 
library(tidyr)
library(dplyr)

# 상호작용 찾기 
pbmc_scriabin <- FindAllInteractionPrograms( 
  pbmc_alzheimer_SCT.combined, iterate.threshold = 300,  
  group.by = "customclassif",  
  sim_threshold = 0.4 
) 

# 중요한 상호작용 찾기  
pbmc_scriabin_sig <- InteractionProgramSignificance(pbmc_scriabin, n.replicate = 500) 

# 최소 하나의 세포 유형에서 중요한 상호작용 찾아 저장하기 
pbmc_scriabin_pvals <- pbmc_scriabin_sig %>% as_tibble() %>% 
  dplyr::select(name,ends_with("pval")) %>% unique() %>% 
  pivot_longer(!name, names_to = "celltype", values_to = "pval") %>% 
  group_by(name) %>% dplyr::mutate(min_p = min(pval)) %>% 
  dplyr::select(name,min_p) %>% unique() %>%  
  dplyr::filter(min_p < 0.05) %>% pull(name) 

pbmc_scriabin_sig <- pbmc_scriabin_sig %>% 
  dplyr::filter(name %in% pbmc_scriabin_pvals) 

# 상호작용 발현에 따라 세포 점수 매기기  
pbmc_alzheimer_SCT.combined <- ScoreInteractionPrograms(pbmc_alzheimer_SCT.combined, pbmc_scriabin_sig)
```

[코드 11-] scriabin 결과 시각화 하기
```{r}
# 힛맵을 그리기 위한 툴 불러오기상호작용 시각화하기 
library(ComplexHeatmap) 
library(tidyverse)

# 리간드 상호작용 세포 유형별 힛맵 - 리간드 
pbmc_scriabin_lig <- as.matrix(pbmc_alzheimer_SCT.combined[["IPligands"]]@data %>% t() %>% 
                                 as.data.frame() %>% 
                                 add_column(celltype = pbmc_alzheimer_SCT.combined$customclassif) %>% 
                                 group_by(celltype) %>% 
                                 summarise_if(is.numeric, mean) %>% 
                                 column_to_rownames("celltype")) 
Heatmap(pbmc_scriabin_lig, show_column_names = F, name = "Ligands") 


# 리간드 상호작용 세포 유형별 힛맵 - 수용체 
pbmc_scriabin_rec <- as.matrix(pbmc[["IPreceptors"]]@data %>% t() %>% 
                              as.data.frame() %>% add_column(celltype = pbmc$customclassif) %>% 
                              group_by(celltype) %>% 
                              summarise_if(is.numeric, mean) %>% column_to_rownames("celltype")) 
Heatmap(pbmc_scriabin_rec, show_column_names = F, name = "Receptors") 
```

# 11.6. 복사수 변이 분석
## Infercnv

## CopyKAT
```{r}
# 필요한 툴 설치 및 불러오기
library(devtools)
install_github("navinlabcode/copykat")
library(copykat)

# 슈랏 오브젝트 데이터 불러와 준비하기
pbmc_sample1 <- Read10X_h5("../data/count_SRR13911909/outs/filtered_feature_bc_matrix.h5")
pbmc_sample1 <- CreateSeuratObject(counts = pbmc_sample1, project = "AD1", min.cells = 3, min.features = 200)
pbmc_sample1 <- NormalizeData(pbmc_sample1)
pbmc_sample1 <- FindVariableFeatures(pbmc_sample1)
all.genes <- rownames(pbmc_sample1)
pbmc_sample1 <- ScaleData(pbmc_sample1, features = all.genes)
pbmc_sample1 <- RunPCA(pbmc_sample1)
pbmc_sample1 <- FindNeighbors(pbmc_sample1, dims = 1:10)
pbmc_sample1 <- FindClusters(pbmc_sample1, resolution = 0.5)
pbmc_sample1 <- RunUMAP(pbmc_sample1, dims = 1:10)

# 세포 별 카운트 원본 데이터를 매트릭스로 저장하기
counts_matrix = LayerData(pbmc_sample1, assay = "RNA", layer = "counts")

# 실행하기 (자동으로 결과가 저장됩니다.) 
copykat.test <- copykat(rawmat= counts_matrix, id.type="S", ngene.chr=5, win.size=25,
KS.cut=0.1, sam.name="test", distance="euclidean", 
norm.cell.names="",output.seg="FLASE", plot.genes="TRUE",
genome="hg20", n.cores=1)
```

## scevan
```{r}
# TODO 

```